# TODO: Movement-System für Schachspiel

## Anforderungen
- Figuren können ausgewählt und bewegt werden (Klick oder Drag/Drop).
- Bewegungen müssen validiert werden:
  - Figuren dürfen nur nach den Regeln ihres Typs ziehen.
  - Hindernisse (außer für Springer) müssen berücksichtigt werden.
  - Bewegungen außerhalb des Schachbretts sind ungültig.
- Spieltempo steuern:
  - Spielerzüge wechseln sich ab (z. B. Weiß zieht, dann Schwarz).
- Bei Kollisionen (gegnerische Figur auf Zielposition):
  - Ziel-Figur wird geschlagen und entfernt.
- Sonderregeln:
  - Rochade
  - En passant
  - Bauernumwandlung

---

## Geplantes Konzept

### 1. Spiellogik
- Zentraler `gameState` (z. B. als Svelte Store), der den Status des gesamten Spiels speichert:
  - Position und Zustand aller Figuren.
  - Welcher Spieler derzeit aktiv ist.
- Beispielzustand:
  - `pieces`: Array mit allen Figuren und ihren Positionen.
  - `activePlayer`: Gibt an, welcher Spieler gerade am Zug ist.

### 2. Validierung von Zügen
- Jede Figur hat eigene Bewegungsregeln:
  - **Pawn (Bauer)**: Nach vorne bewegen, diagonal schlagen.
  - **Rook (Turm)**: Horizontal oder vertikal ziehen.
  - **Knight (Springer)**: "L"-förmige Sprünge (ignoriert Hindernisse).
  - **Bishop (Läufer)**: Diagonal ziehen.
  - **Queen (Dame)**: Horizontal, vertikal und diagonal ziehen.
  - **King (König)**: Ein Feld in jede Richtung.
- Hindernisse müssen geprüft werden:
  - Figuren dürfen nicht durch andere hindurchziehen.
- Züge werden durch Funktionen validiert, die Start- und Zielposition prüfen.

---

### 3. Benutzerinteraktion
- Figuren können wie folgt bewegt werden:
  - Per Klick:
    1. Figur auswählen (Klick auf die Figur).
    2. Zielposition wählen (Klick auf das Zielfeld).
  - Per Drag & Drop:
    1. Figur "ziehen".
    2. Figur loslassen, um Zielposition festzulegen.
- Zielpositionen müssen für Benutzer klar hervorgehoben werden.

---

### 4. Zwei-Spieler-Modus
- Aktiver Spieler wechseln:
  - Nach jedem Zug sollte automatisch zum anderen Spieler gewechselt werden.
  - Beispiel: Nach einem Zug von Weiß zieht Schwarz.
- Status prüfen:
  - Spieler sollten nur ihre eigenen Figuren bewegen können.
- Optional: Online-Multiplayer:
  - Zustände zwischen zwei Spielern synchronisieren (z. B. über Websockets).

---

## Technische Umsetzung

### Zentraler State (Spielstatus)
- Speichert die aktuelle Position aller Schachfiguren und den Zustand des Spiels.
- Lädt die Startaufstellung zu Beginn des Spiels:
  - `startConfiguration` als Grundlage.
- Sobald eine Figur bewegt wurde:
  - Zielposition aktualisieren.
  - Geschlagene Figuren entfernen.
  - Aktiven Spieler wechseln.

---

### Validierung (Zugprüfung)
- Jede Figur erhält eigene Validierungslogik:
  - **Input**: Start- und Zielposition, Spielstatus (z. B. Hindernisse).
  - **Output**: Boolean (`true` = gültig, `false` = ungültig).
- Beispiel für Bauern:
  - Ein Feld vorwärts (oder zwei Felder beim ersten Zug).
  - Diagonal schlagen, falls ein Gegner auf der Zielposition ist.

---

### Bewegung und Spielerwechsel
- Spieleractions (z. B. Figurenbewegung) updaten den `gameState`:
  - Position der Figur ändern.
  - Geschlagene Figuren entfernen.
  - Wechseln des aktiven Spielers nach jedem Zug.
- Validierung wird vor dem Update ausgeführt:
  - Ungültige Züge werden verworfen.

---

## Nächste Schritte
1. `gameState` erstellen und mit Startaufstellung laden.
2. Interaktionsmodul entwickeln (z. B. Auswahl von Figuren und Zielfeldern per Klick).
3. Validierungsfunktionen für alle Figuren umsetzen.
4. Spielerwechsel-Logik integrieren.
5. Drag/Drop für intuitivere Bewegung hinzufügen.
6. Sonderfunktionen (Rochade, En passant, Bauernumwandlung) in die Logik integrieren.
7. Optional: Multiplayer-Integration für zwei Spieler.